<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>bydimov - Portfolio</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            min-height: 100vh;
            margin: 0;
            font-family: sans-serif;
            background-color: #000;
            overflow-x: hidden;
        }

        /* 3D Canvas на фоне */
        #bg-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: 0;
            pointer-events: auto;
        }

        /* Контент поверх canvas */
        .content-wrapper {
            position: relative;
            z-index: 10;
            pointer-events: none;
        }

        nav {
            backdrop-filter: blur(30px);
            box-shadow: 0px 0px 30px 0 rgba(227, 228, 237, 0.37);
            border-bottom: 2px solid rgba(255, 255, 255, 0.18);
            width: 100%;
            padding: 20px 0;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1000;
            pointer-events: auto;
        }

        ul {
            display: flex;
            gap: 3rem;
            list-style: none;
            justify-content: center;
            align-items: center;
            margin: 0;
            padding: 0;
        }

        ul li {
            color: #fff;
            display: flex;
            align-items: center;
            margin: 0;
        }

        .logo {
            color: #fff;
            cursor: pointer;
            font-size: 2.5rem;
            margin-right: 2rem;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        .menu {
            color: #fff;
            padding: 0.5rem 1rem;
            position: relative;
            text-decoration: none;
            font-size: 1.2rem;
            transition: all 0.3s ease;
        }

        .menu::before {
            content: "";
            position: absolute;
            width: 100%;
            height: 2px;
            background: #fff;
            border-radius: 5px;
            transform: scaleX(0);
            transition: all .5s ease;
            bottom: 0;
            left: 0;
        }

        .menu:hover::before {
            transform: scaleX(1);
        }

        .menu:hover {
            color: #00fffc;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }

        /* Адаптивность для мобильных */
        @media (max-width: 768px) {
            ul {
                gap: 1rem;
                flex-wrap: wrap;
                padding: 0 20px;
            }

            .logo {
                font-size: 2rem;
                margin-right: 1rem;
            }

            .menu {
                font-size: 1rem;
                padding: 0.5rem;
            }
        }
    </style>
</head>

<body>
    <!-- 3D Canvas фон -->
    <canvas id="bg-canvas"></canvas>

    <!-- Контент сайта -->
    <div class="content-wrapper">
        <nav>
            <ul>
                <li class="logo">bydimov</li>
            <li><a href="drive-mad/dist/index.html" class="menu">Drive</a></li>
            <li><a href="game-card/index.html" class="menu">Card</a></li>
            <li><a href="fire/fireworks-launcher.html" class="menu">Fire</a></li>
            <li><a href="life/life.html" class="menu">Life</a></li>
            <li><a href="treker/treker.html" class="menu">Habit Tracker</a></li>
            </ul>
        </nav>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.162.0/build/three.module.js",
            "three/addons/controls/OrbitControls.js": "https://unpkg.com/three@0.162.0/examples/jsm/controls/OrbitControls.js"
        }
    }
    </script>

    <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const canvas = document.getElementById('bg-canvas');
    
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.01);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ 
        canvas: canvas,
        antialias: true,
        powerPreference: "high-performance",
        alpha: true
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000);
    renderer.setPixelRatio(window.devicePixelRatio);

    const controls = new OrbitControls(camera, canvas);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.rotateSpeed = 0.5;
    controls.minDistance = 10;
    controls.maxDistance = 30;
    controls.enableZoom = true;

    camera.position.z = 15;
    camera.position.y = 5;
    controls.target.set(0, 0, 0);
    controls.update();

    const pointMaterialShader = {
        vertexShader: `
            attribute float size;
            varying vec3 vColor;
            varying float vDistance;
            uniform float time;
            
            void main() {
                vColor = color;
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                vDistance = -mvPosition.z;
                float pulse = sin(time * 2.0 + length(position)) * 0.15 + 1.0;
                vec3 pos = position;
                pos.x += sin(time + position.z * 0.5) * 0.05;
                pos.y += cos(time + position.x * 0.5) * 0.05;
                pos.z += sin(time + position.y * 0.5) * 0.05;
                mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_PointSize = size * (300.0 / -mvPosition.z) * pulse;
                gl_Position = projectionMatrix * mvPosition;
            }
        `,
        fragmentShader: `
            varying vec3 vColor;
            varying float vDistance;
            uniform float time;
            
            void main() {
                vec2 cxy = 2.0 * gl_PointCoord - 1.0;
                float r = dot(cxy, cxy);
                if (r > 1.0) discard;
                float glow = exp(-r * 2.5);
                float outerGlow = exp(-r * 1.5) * 0.3;
                vec3 finalColor = vColor * (1.2 + sin(time * 0.5) * 0.1);
                finalColor += vec3(0.2, 0.4, 0.6) * outerGlow;
                float distanceFade = 1.0 - smoothstep(0.0, 50.0, vDistance);
                float intensity = mix(0.7, 1.0, distanceFade);
                gl_FragColor = vec4(finalColor * intensity, (glow + outerGlow) * distanceFade);
            }
        `
    };

    function createSpiralSphere(radius, particleCount, colors) {
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const particleColors = [];
        const sizes = [];
        
        for (let i = 0; i < particleCount; i++) {
            const phi = Math.acos(-1 + (2 * i) / particleCount);
            const theta = Math.sqrt(particleCount * Math.PI) * phi;
            const x = radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.sin(phi) * Math.sin(theta);
            const z = radius * Math.cos(phi);
            positions.push(x, y, z);
            const colorPos = i / particleCount;
            const color1 = colors[Math.floor(colorPos * (colors.length - 1))];
            const color2 = colors[Math.ceil(colorPos * (colors.length - 1))];
            const mixRatio = (colorPos * (colors.length - 1)) % 1;
            const finalColor = new THREE.Color().lerpColors(color1, color2, mixRatio);
            particleColors.push(finalColor.r, finalColor.g, finalColor.b);
            sizes.push(Math.random() * 0.15 + 0.08);
        }
        
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(particleColors, 3));
        geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
        
        const material = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 }
            },
            vertexShader: pointMaterialShader.vertexShader,
            fragmentShader: pointMaterialShader.fragmentShader,
            vertexColors: true,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });
        
        return new THREE.Points(geometry, material);
    }

    function createOrbitRings(radius, count, thickness) {
        const group = new THREE.Group();
        
        for (let i = 0; i < count; i++) {
            const ringGeometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const sizes = [];
            const particleCount = 3000;
            
            for (let j = 0; j < particleCount; j++) {
                const angle = (j / particleCount) * Math.PI * 2;
                const radiusVariation = radius + (Math.random() - 0.5) * thickness;
                const x = Math.cos(angle) * radiusVariation;
                const y = (Math.random() - 0.5) * thickness;
                const z = Math.sin(angle) * radiusVariation;
                positions.push(x, y, z);
                const hue = (i / count) * 0.7 + (j / particleCount) * 0.3;
                const color = new THREE.Color().setHSL(hue, 1, 0.6);
                color.multiplyScalar(1.2);
                colors.push(color.r, color.g, color.b);
                sizes.push(Math.random() * 0.12 + 0.06);
            }
            
            ringGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            ringGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            ringGeometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: pointMaterialShader.vertexShader,
                fragmentShader: pointMaterialShader.fragmentShader,
                vertexColors: true,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });
            
            const ring = new THREE.Points(ringGeometry, material);
            ring.rotation.x = Math.random() * Math.PI;
            ring.rotation.y = Math.random() * Math.PI;
            group.add(ring);
        }
        
        return group;
    }

    const sphereColors = [
        new THREE.Color(0x00ffff).multiplyScalar(1.2),
        new THREE.Color(0xff1493).multiplyScalar(1.1),
        new THREE.Color(0x4169e1).multiplyScalar(1.2),
        new THREE.Color(0xff69b4).multiplyScalar(1.1),
        new THREE.Color(0x00bfff).multiplyScalar(1.2)
    ];

    const coreSphere = createSpiralSphere(4, 25000, sphereColors);
    const orbitRings = createOrbitRings(5.8, 6, 0.4);

    const mainGroup = new THREE.Group();
    mainGroup.scale.set(1.2, 1.2, 1.2);
    mainGroup.add(coreSphere);
    mainGroup.add(orbitRings);
    scene.add(mainGroup);

    let time = 0;

    function animate() {
        requestAnimationFrame(animate);
        time += 0.002;
        coreSphere.material.uniforms.time.value = time;
        orbitRings.children.forEach(ring => {
            ring.material.uniforms.time.value = time;
        });
        coreSphere.rotation.y += 0.001;
        coreSphere.rotation.x = Math.sin(time * 0.5) * 0.15;
        orbitRings.children.forEach((ring, index) => {
            const dynamicSpeed = 0.001 * (Math.sin(time * 0.2) + 2.0) * (index + 1);
            ring.rotation.z += dynamicSpeed;
            ring.rotation.x += dynamicSpeed * 0.6;
            ring.rotation.y += dynamicSpeed * 0.4;
        });
        const breathe = 1 + Math.sin(time * 1.5) * 0.1;
        coreSphere.scale.set(breathe, breathe, breathe);
        controls.update();
        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        const width = window.innerWidth;
        const height = window.innerHeight;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
    });

    animate();
    </script>
</body>


</html>

